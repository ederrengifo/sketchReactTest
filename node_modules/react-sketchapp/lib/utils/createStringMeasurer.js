'use strict';

var _types = require('../types');

var _findFont = require('./findFont');

var _findFont2 = _interopRequireDefault(_findFont);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// TODO(lmr): do something more sensible here
var FLOAT_MAX = 999999;

var createStringMeasurer = function createStringMeasurer(string, style) {
  return function (width) {
    var font = (0, _findFont2.default)(style);
    var attributes = _defineProperty({}, NSFontAttributeName, font);

    if (style.lineHeight !== undefined) {
      // NOTE(gold): Visual explanation of NSParagraphStyle
      // https://medium.com/@at_underscore/nsparagraphstyle-explained-visually-a8659d1fbd6f
      var paragraphStyle = NSMutableParagraphStyle.alloc().init();
      paragraphStyle.minimumLineHeight = style.lineHeight;
      paragraphStyle.lineHeightMultiple = 1.0;
      paragraphStyle.maximumLineHeight = style.lineHeight;
      attributes[NSParagraphStyleAttributeName] = paragraphStyle;
    }

    if (style.letterSpacing !== undefined) {
      attributes[NSKernAttributeName] = style.letterSpacing;
    }

    var rect = NSString.alloc().initWithString(string).boundingRectWithSize_options_attributes_context(CGSizeMake(width, FLOAT_MAX), NSStringDrawingUsesLineFragmentOrigin, attributes, null);

    // TODO(lmr): handle other widthModes, and height/heightModes

    return {
      width: 0 + rect.size.width,
      height: 0 + rect.size.height
    };
  };
};

module.exports = createStringMeasurer;